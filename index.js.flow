// @flow
import path from "path";

const bindings = require("node-gyp-build")(__dirname);

export type MappingPosition = {|
  line: number,
  column: number
|};

export type IndexedMapping<T> = {
  generated: MappingPosition,
  original?: MappingPosition,
  source?: T,
  name?: T,
  ...
};

export type ParsedMap = {|
  sources: Array<string>,
  names: Array<string>,
  mappings: Array<IndexedMapping<number>>
|};

export type VLQMap = {
  sources: Array<string>,
  names: Array<string>,
  mappings: string,
  ...
};

export type SourceMapStringifyOptions = {
  file?: string,
  sourceRoot?: string,
  rootDir?: string,
  inlineSources?: boolean,
  inlineMap?: boolean,
  fs?: {
    readFile: (filepath: string, encoding: string) => any,
    ...
  },
  ...
};

function generateInlineMap(map) {
  return `data:application/json;charset=utf-8;base64,${Buffer.from(
    map
  ).toString("base64")}`;
}

export default class SourceMap {
  sourceMapInstance: any;

  constructor() {
    this.sourceMapInstance = new bindings.SourceMap();
  }

  // addEmptyMap(sourceName: string, sourceContent: string, lineOffset: number = 0): SourceMap
  addEmptyMap(
    sourceName: string,
    sourceContent: string,
    lineOffset: number = 0
  ) {
    this.sourceMapInstance.addEmptyMap(sourceName, sourceContent, lineOffset);
    return this;
  }

  addRawMappings(
    mappings: string,
    sources: Array<string>,
    names: Array<string>,
    lineOffset: number = 0,
    columnOffset: number = 0
  ) {
    this.sourceMapInstance.addRawMappings(
      mappings,
      sources,
      names,
      lineOffset,
      columnOffset
    );
    return this;
  }

  addBufferMappings(
    buffer: Buffer,
    lineOffset: number = 0,
    columnOffset: number = 0
  ) {
    this.sourceMapInstance.addBufferMappings(buffer, lineOffset, columnOffset);
    return this;
  }

  // line numbers start at 1 so we have the same api as `source-map` by mozilla
  addIndexedMappings(
    mappings: Array<IndexedMapping<number | string>>,
    lineOffset?: number = 0,
    columnOffset?: number = 0
  ) {
    this.sourceMapInstance.addIndexedMappings(
      mappings,
      lineOffset,
      columnOffset
    );
    return this;
  }

  addNames(names: Array<string>): Array<number> {
    return this.sourceMapInstance.addNames(names);
  }

  addSources(sources: Array<string>): Array<number> {
    return this.sourceMapInstance.addSources(sources);
  }

  getSourceIndex(source: string): number {
    return this.sourceMapInstance.getSourceIndex(source);
  }

  getNameIndex(name: string): number {
    return this.sourceMapInstance.getNameIndex(name);
  }

  findClosestMapping(line: number, column: number): IndexedMapping<number> {
    return this.sourceMapInstance.findClosestMapping(line, column);
  }

  // Remaps original positions from this map to the ones in the provided map
  extends(buffer: Buffer) {
    this.sourceMapInstance.extends(buffer);
    return this;
  }

  getMap(): ParsedMap {
    return this.sourceMapInstance.getMap();
  }

  toBuffer(): Buffer {
    return this.sourceMapInstance.toBuffer();
  }

  toVLQ(): VLQMap {
    return this.sourceMapInstance.stringify();
  }

  async stringify({
    file,
    sourceRoot,
    rootDir,
    inlineSources,
    inlineMap,
    fs
  }: SourceMapStringifyOptions) {
    let map = this.sourceMapInstance.stringify();
    map.version = 3;
    map.file = file;
    map.sourceRoot = sourceRoot;

    if (inlineSources && fs) {
      map.sourcesContent = await Promise.all(
        map.sources.map(async sourceName => {
          try {
            return await fs.readFile(
              path.join(rootDir || "", sourceName),
              "utf-8"
            );
          } catch (e) {
            return null;
          }
        })
      );
    }

    let stringifiedMap = JSON.stringify(map);
    return inlineMap ? generateInlineMap(stringifiedMap) : stringifiedMap;
  }
}

export function generateEmptyMap(
  sourceName: string,
  sourceContent: string,
  lineOffset: number = 0
): SourceMap {
  let map = new SourceMap();
  map.addEmptyMap(sourceName, sourceContent, lineOffset);
  return map;
}
